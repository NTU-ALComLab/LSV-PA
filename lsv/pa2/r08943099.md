# LSV PA2 Report
Testing Unateness of Primary Outputs
## Implementation

### DataStructure
- Abc_Ntk_t
- Abc_Obj_t
- Aig_Man_t
### Steps and API used
這個題目為判斷NTK PO的PosUnate，所以必須使用`Abc_NtkForEachPo()`來遍歷每個PO, 再來使用`Abc_NtkForEachPi()`以遍歷每個Po所對應的Pi，再進行SAT Solving。。
1. 使用`Abc_NtkCreateCone()`將PO轉換成TFI Cone的形式，接下來找到其對應的PI。值得注意的是因為使用了TFI Cone的，所以PI Index of Cone，也許會與PI Index of Ntk不盡相同，所以必須記錄下來。這裡使用了一連串`unordered_map()`，使得只要輸入PI Name就可以找到Index of Ntk.
2. 要進行SAT Soving前必須得到Cnf的形式，且必須將電路複製兩份以進行運算。使用`Abc_NtkToDar()`得到AIG電路，在使用`Cnf_Derive()`與`Cnf_DataDup()`分別得到CnfPos與CnfNeg，而為了區分變數利用`Cnf_DataLift()`轉換一下CnfNeg.
3. 接下來使用`sat_solver_new()`來建立一個新的solver，利用`sat_solver_setnvars()`將兩個Cnf建立變數，再使用`sat_solver_addclause()`來添加clause到solver中。
4. 要使得PI為SAT,可以加入αi，並建立claues:(¬αi ∨ Pi_i_pos ∨ ¬Pi_i_neg) ∧ (¬αi ∨ ¬Pi_i_pos ∨ Pi_i_neg)來測試來測試,且當測試Pi_i時要讓要讓αi為0,其他為1,使用`toLitCond()`來做設定。
5. 使用`sat_solver_solve()`做完SAT solver後,可以根據Positive unate with x=0 then F=1, and x=1 then F=0這個條件判斷，當結果為UnSAT，則表示此PI為Positive Unate;而Negative Unate即為相反。
6. 印出結果


## Discussion
1. Can your implementation solve the remaining 7 test
cases (possibly with a longer time limit)?  
2. How does your implementation compared to the BDD-
based command `print_unate` in ABC?
3. What are the differences between random control and
arithmetic circuits? Which category is more challenging?