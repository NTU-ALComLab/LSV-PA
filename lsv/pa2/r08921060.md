# Programming Assignment 2 report
## Big picture
1. Add the two copies of original circuit into SAT solver, denoted as *F* and *G* repectively.
1. Add the constrain (F)(~G) into SAT solver, which means ~(F->G).
1. Add the constrain (x_F == x_G), which is equilivent to (x_F + x_G + ~x_c)(~x_F + x_G + ~x_c) into SAT solver for all PI x in F and G, where x_c is the contral variable. Set x_c = 0 means turn off the equivilant constrain on PI x, while x_c = 1 means turn on the equivilant constrain.
1. Add the assumption (~x_F)(x_G)(~x_c) into sat solver, which means setting PI x in *F* to be 0 and x in *G* to be 1. Also, turn off the equivilant constrain on x by seeting x_c = 0. In addition, set y_c = 1 for all the other PI y, which means turn on the equivilant constrain to force all the other PI be the same in *F* and *G*.
1. Solve the SAT solver. If it is SAT, we find a counter example and thus F(x = 0) -> G(x = 1) is false. which means this PI is not positive unate with respect to this PO. On the other hand, if it is UNSAT, we can conclude that it is positive unate. We can check negitive unate by changing the assuption (~x_F)(x_G)(~x_c) to (x_F)(~x_G)(~x_c).

## Implementation detail

1. Get single output `Abc_Ntk_t`(called *abcNtk_1Po*):
   1. use the function `Abc_FrameReadNtk` to get the `Abc_Ntk_t` of entire circuit(called *abcNtk*) from `Abc_Frame_t`.
   1. for all PO of *abcNtk*, use the function `Abc_NtkCreateCone` to get the single output *abcNtk_1Po*.
      * The returned `Abc_Ntk_t` will create a new PO with positive edge, which means the polarity of PO might be different from the original circuit. We need to check the original PO polarity by the function `Abc_ObjFaninC0`, and reverse the new PO if necessary.
      
1. Get `Aig_Man_t`(called *aigMan*):
   1. use the function `Abc_NtkToDar` to get *aigMan* from *abcNtk_1Po*.
1. Get two copys of `Cnf_Dat_t`(called *F* and *G* repectively):
   1. use the function `Cnf_Derive` to get *F* from *aigMan*.
   1. copy *F* by `Cnf_DataDup` to get *G*.
   1. use `Cnf_DataLift` to rename the variable of *G*.
      * we shift each variable by adding `Cnf_Dat_t->nVars - 1`.
1. Get `sat_solver`(called *satSol*)
   1. use the function `Cnf_DataWriteIntoSolver` to create a new SAT solver by adding the clause of *F*.
   1. use the iterator API `Cnf_CnfForClause` to add each clauses of *G* by function `sat_solver_addclause`.
   1. add the constrain **~(F->G)** into *satSol*, which is equivalent to adding two single literal clauses (*F*) and (~*G*)
      1. use `Aig_ManCo` to get the PO(`Abc_Obj_t`) of *F*
      1. use `Aig_ObjId` to get the ID of this PO
      1. use `Cnf_Dat_t->pVarNums` to get the variable of this PO
      1. use `toLitCond` to get the literal of this variable
      1. store this literal in pLists[0], which represent a single literal clause
      1. use `sat_solver_addclause` to add this clause to satSol as constrain
      1. repeat the above process for (~*G*)
   1. add the constrain **(x_F == x_G)**
      1. use the function `Cnf_DataCollectPiSatNums` to get the variable of CIs in *abcNtk_1Po*
      1. use `sat_solver_addvar` to create a new variable as control variable
      1. use `sat_solver_add_buffer_enable` to add these constrain to *satSol*
      1. store this control variable in an array called *constrainSet*
1. Find the unateness
   1. for each PI x, create the assumption mentioned in section `Big picture` and collect them to a single clause *pLits*.
   1. use `sat_solver_solve` to solve the SAT solver with these assumption.
   1. If it is UNSAT, we find positive unate. Otherwise, we repeat the process to check negitive unate. If both result is SAT, which means it is neither positive unate or negitive unate, it is binate.
   1. use vectors to record the result.
1. Print the result
   1. sort the record vector by ID and print the result.
   
## Optimization
1. Do not use all the PI when getting *abcNtk_1Po*.

   Set the last parameter of `Abc_NtkCreateCone` as 0, which means the returned `Abc_Ntk_t` will ignore the PI if it is not related to current PO. And thus the ID of PI in `abcNtk_1Po`(`Abc_Ntk_t`) will be different from the ID of PI in `abcNtk`(`Abc_Ntk_t`). As the result, we need to compare the node name by `Abc_ObjName` to identified which node we are considering now when finding the unateness. In addition, with the observation that the new PI is also in the order same as original `Abc_Ntk_t`(but might skip some independent PI), we can compare the name in linear time by record the index, instead of checking from head all the time(which is O(n^2) ).
   
1. Identified constant PO and view all of its PI as both positive and negtive unate.

   When trying to add the constrain of (*F*)(~*G*), `sat_solver_addclause` will return false if it is totalogy. Once we find that *F*( or *G*) is constant, we can conclude that all of its PI is independant to it, and thus they should be both positive and negitive unate. We simply print the answer earlier without doing the remaining process.
   
1. Take care of memory leak  

   By carefully using the memory control API such as `ABC_ALLOC` and `ABC_FREE`, we can make good use of memory and reduce the risk of memory leak, which might improve the overall performance in general. 
  
1. Other petty details
   1. using `reserve()` once we create a new vector, which can avoid data copy when the capacity is not enough in the future.
   1. pass the parameter by pointer or reference when calling function, which can avoid data copy. Also add key word `const` if possiable to ease the compile.
   1. record the vector size first instrad of repeatedly calling `size()` during the for-loop constrain checking.

## Experiment and some observation
1. Before doing the optimization mentioned in the above section, I can only pass the 11/13 test case. The test case `sin.aig` and `mem_ctrl.aig` will fail due to timeout. However, after doing the optimization **Do not use all the PI when getting abcNtk_1Po**, all of 13 test cases can be done.
1. Using SAT solver can solve larger circuit than using BDD, since BDD has shortage in nearly exponential grow up in memory requirement.
1. Solving the test cases in random control is more faster than solving the test cases in arithmetic circuits.
