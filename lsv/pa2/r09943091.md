# My Implementation
## Extra Data Structure
- Struct inputnode: 
   他記住pNtk的每個CI的原始ID，Name，以及每次cone完後的新ID（若無cone到則該CI的新ID則紀錄成-1）。
- map:
   使我create cone完後，可以利用name找回cone內的CI的原始ID。


## Using API and it's meaning
- Abc_NtkForEachPo/Pi：
   每次得到不同的CO/Ci來操作。
- Abc_NtkCreateCone：
   可以直接cone某個node。
- Abc_NtkToDar：
   將Abc_Ntk轉乘Aig形式
- Aig_ManCo：
   根據第二個參數當作index，得到Aig形式下的第index個CO
- Cnf_Derive: 
   將AIG轉乘一堆clause
- Cnf_DataDup + Cnf_DataLift:
   將clause全部複製一份，並平移var編號
- sat_solver_new + sat_solver_setnvars:
   創建一個SAT_solver object，以及有效變數範圍
- sat_solver_addclause:
   將clause一個一個放入
- sat_solver_add_buffer_enable：
   以一個新變數來控制另外兩個圓有變數是否需要相等
- sat_solver_solve：
   實際去解SAT，看是否能成功
    


## Implementation flow
- 先根據每個CO來cone，並同步更新inputnode struct的資料
- 接下來將cone轉乘AIG，通常CI的ID會恰為1~CI number
- 進一步轉成Cnf，並複製平移一份Cnf2，來建造出 Fx 和 F~x
- 創建一個sat object，並把Cnf內的每個clause一個一個放入，每呼叫一次addclause就代表新增一個，所以不能一次全放入pClause。
- 新增enable variable使Cnf和Cnf2的input value除了x之外會相同。
- assume非x的enable variable為1，x的則一個1一個0
- 當為positive unate時，代表F(~x)->F(x) 所以不能 (F(~x) and ~F(x)) so assume F(~x) = 1 and F(x) = 0
- 當為negitive unate時，代表F(x)->F(~x) 所以不能 (~F(~x) and F(x)) so assume F(~x) = 0 and F(x) = 1
- 當上述兩個被找出SAT時，代表有反例，所以不是unate反之則是。
- 就這樣每個CO都針對cone內的每個CI做一次，即可得結果
- PI不再CI內，則代表PI不影響該次CO，所以上述的positive unate和negitive unate的都會成立。


## Result
1. Bottleneck is benchmarks/random_control/mem_ctrl.aig
    在我的電腦上跑要多達3分5秒，有點不太確定在其他地方跑的結果是否能在5分內。