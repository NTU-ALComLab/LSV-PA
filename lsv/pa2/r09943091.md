# My Implementation
## Extra Data Structure
1. Struct inputnode: 
   他記住pNtk的每個CI的原始ID，Name，以及每次cone完後的新ID（若無cone到則該CI的新ID則紀錄成-1）。
2. map:
   使我create cone完後，可以利用name找回cone內的CI的原始ID。


## Using API and it's meaning
1. Abc_NtkForEachPo/Pi：
   每次得到不同的CO/Ci來操作。
3. Abc_NtkCreateCone：
   可以直接cone某個node。
3. Abc_NtkToDar：
   將Abc_Ntk轉乘Aig形式
4. Aig_ManCo：
   根據第二個參數當作index，得到Aig形式下的第index個CO
5. Cnf_Derive: 
   將AIG轉乘一堆clause
6. Cnf_DataDup + Cnf_DataLift:
   將clause全部複製一份，並平移var編號
7. sat_solver_new + sat_solver_setnvars:
   創建一個SAT_solver object，以及有效變數範圍
8. sat_solver_addclause:
   將clause一個一個放入
9. sat_solver_add_buffer_enable：
   以一個新變數來控制另外兩個圓有變數是否需要相等
10. sat_solver_solve：
    實際去解SAT，看是否能成功
    


## Implementation flow


## Result
1. Bottleneck is benchmarks/random_control/mem_ctrl.aig
    在我的電腦上跑要多達3分5秒，有點不太確定在其他地方跑的結果是否能在5分內。
 