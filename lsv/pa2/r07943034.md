# Programming Assignment 2 : Testing Unateness of Primary Outputs

Problem description is on this [**README**](https://github.com/NTU-ALComLab/LSV-PA/blob/master/lsv/pa2/README.md)

## Implementation

For each primary output, it can be treated as a single output function with respect to its supports. To derive the unate information for each primary output in terms of all primary inputs, we can prove the unate property by finding a counter example using SAT solver. 
We say that a primary output _f_ is _positive unate_ in terms of a primary input _x_ if its function _F_ (encoded by the AIG) satisfies _F(...,x=0,...) &rarr; F(...,x=1,...)_. The counter example will be _F(...,x=0,...) > F(...,x=1,...)_, that is, _F(...,x=0,...)==1 \wedge F(...,x=1,...)==0_. Similarly, negative unate can be proved by this method.

## Experiments

The experiments were run on a Intel(R) Core(TM) i7-8700 CPU at 3.20GHz. The time limit is set to 600 seconds.
| Benchmark     | `print_unate` | `lsv_print_pounate(mine)` | `lsv_print_pounate(ref)` |
| ------------- | -------------:| -------------------------:| ------------------------:|
| arbiter.aig   |          3.76 |                      4.34 |                     4.28 |
| cavlc.aig     |          0.01 |                      0.03 |                     0.03 |
| ctrl.aig      |          0.02 |                      0.03 |                     0.02 |
| dec.aig       |          0.02 |                      0.07 |                     0.08 |
| i2c.aig       |          0.04 |                      0.08 |                     0.09 |
| int2float.aig |          0.02 |                      0.02 |                     0.03 |
| mem_ctrl.aig  |         13.11 |                     106.5 |                   121.21 |
| priority.aig  |          0.04 |                      0.12 |                     0.09 |
| router.aig    |          0.02 |                      0.03 |                     0.04 |
| adder.aig     |          0.16 |                      2.40 |                     2.61 |
| bar.aig       |         13.72 |                      2.18 |                     2.19 |
| max.aig       |            TO |                      47.5 |                    47.09 |
| sin.aig       |            TO |                     10.83 |                    10.82 |


## Questions

- Can your implementation solve the remaining 7 test cases (possibly with a longer time limit)?
    - The implementation cannot solve the 7 cases within 300s and 600s. 
- How does your implementation compare to the BDD-based command `print_unate` in ABC?
    - See [Experiments](#Experiments) for comparison. `print_unate` tend to be faster on simpler cases, but fails to give answer on harder cases, such as arithmetic circuits.
- What are the differences between random control and arithmetic circuits? Which category is more challenging?
    - Considering the experiments and the remaining 7 test cases, arithmetic circuits seems to be more challenging than random control circuits.

## Future Works
For future works, circuit simulation could be added before SAT solving to quickly detect non-unateness of inputs. 

