The report should describe your implementation, including
the data structures/APIs you use and your optimization
over the baseline approach.

The following topics are not required but you are
encouraged to discuss them in your report:
- Can your implementation solve the remaining 7 test
cases (possibly with a longer time limit)?
- How does your implementation compared to the BDD-
based command `print_unate` in ABC?
- What are the differences between random control and
arithmetic circuits? Which category is more challenging?

Logic Sythesis & Verification Programming Assignment 2 Report
R08943098 Shao-Wei Chu

Section: Topic
Unateness checking of global PI/PO.
Section: Implementation
The unateness of for each primary output in terms of all primary inputs are reasoned with SAT solver.

Pseudo code

For each PO:
    Get cone
    Create SAT instance
    for each Pi:
        Solve(Fx' ^ \neg Fx) // UNSAT if positive unate 
        Solve(\neg Fx' ^  Fx) // UNSAT if negative unate
    Get PIs which are not transtive fanin of cone
    Print

Part of the APIs used are listed as follows:
    Abc_NtkCreateCone(): get cone of some PO
    Abc_NtkToDar(): get AIG from network
    Cnf_Derive(): get CNF from AIG
    Cnf_DataLift(): corrects the variable ID when added to SAT solver
    sat_solver_solve(): solve with assumptions

Here incremental solving is applied. A single solver is built and each PI is iterated through changing assumptions. Also, to further speed up the solving, we break down each PO, that is, a single solver is built for each cone. This scales down the CNF effectively, and allows it to solve two more cases (11 -> 13 cases).

The experimental results on EPFL benchmarks are as follows. We compare our implementation "lsv_print_pounate" to the ABC built-in BDD-based "print_unate" command. The remaining 7 benchmarks are included and marked as orange.

// TABLE

The columns from left to right represents the type of the benchmark, name of the benchmark, number of PI, number of PO, AIG node size, AIG level, runtime of "lsv_print_pounate", shared BDD size of "print_unate", and runtime of "print_unate".

It can be seen that BDD-based implementation solves small benchmarks faster than SAT-based method. However, as the benchmarks grow larger, the size of BDD blow up, resulting in inefficient solving.

Also, the solving of arithmetic circuits are harder than solving random control circuits.